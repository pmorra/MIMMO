!!-----------------------------------------------------------------------------!!
!!-----------------------------------------------------------------------------!!
!!                                                                             !!
!!     MMMM     MMMM   MMMM   MMMM     MMMM   MMMM     MMMM      MMMMMM        !!
!!     MMMMMM MMMMMM   MMMM   MMMMMM MMMMMM   MMMMMM MMMMMM    MMMMMMMMMM      !!
!!     MMMMMMMMMMMMM   MMMM   MMMMMMMMMMMMM   MMMMMMMMMMMMM   MMMM    MMMM     !!
!!     MMMM MMM MMMM   MMMM   MMMM MMM MMMM   MMMM MMM MMMM   MMMM    MMMM     !!
!!     MMMM  M  MMMM   MMMM   MMMM  M  MMMM   MMMM  M  MMMM   MMMM    MMMM     !!
!!     MMMM     MMMM   MMMM   MMMM     MMMM   MMMM     MMMM    MMMMMMMMMM      !!
!!     MMMM     MMMM   MMMM   MMMM     MMMM   MMMM     MMMM      MMMMMM        !!
!!                                                                             !!
!!-----------------------------------------------------------------------------!!
!!                                                                             !!
!!     (c) Pierluigi Morra                                                     !!                       
!!         Stockholm, 2017                                                     !!
!!         email: pmorra@mech.kth.se                                           !!                                    
!!                                                                             !!
!!-----------------------------------------------------------------------------!!

!!                                                                             !!
!!  Linear Multiple-Input-Multiple-Output Controller:                          !!
!!                                                                             !!
!!    The following program can be used to simulate the behavior of a control  !!
!!    law on a linear system.                                                  !!
!!    The program assumes the user gives as inputs the signals and the kernel  !!  
!!    functions if needed. Then, it computes the actuation signals needed to   !!  
!!    reach the desired behavior.                                              !!   
!!                                                                             !!
!!    The assumption of a linear system is seen in the signals. Those should   !!
!!    come from measures on a linear system. If they do not come from such a   !!
!!    system, the actuation influence on the system is unknown because it can  !!
!!    not be described as the superimposition of the old signal and the one    !!
!!    generated by the actuation alone.                                        !!
!!                                                                             !!
!!    NOTE:                                                                    !!
!!    At the current status, the filtered-x least mean square (FxLMS) control  !!
!!    is implemented, which requires some external kernel functions other than !!   
!!    the signals.                                                             !!   
!!    The control law implemented is the same FxLMS found in SIMSON.           !!
!!                                                                             !!

!!=============================================================================!!

!!-----------------------------------------------------------------------------!!
!!-----------------------------------------------------------------------------!!
!!                                                                             !!
!!                               MAIN PROGRAM                                  !!
!!                                                                             !!
!!-----------------------------------------------------------------------------!!
!!-----------------------------------------------------------------------------!!

program main
  !! ---  DECLARE VARIABLES --- !!
  implicit none
  
  INTERFACE
    subroutine read_fir(fid,fname,dt,nt,nz,H)
      integer,           intent(in)    :: fid
      character*120,     intent(in)    :: fname
      real,              intent(out)   :: dt
      integer,           intent(out)   :: nt(2), nz(2)
      real, allocatable, intent(out)   :: H(:,:)
    end subroutine
    subroutine read_control(fid,fname,content,signal,t,a,b,c,d,e)
      integer,      intent(in) :: fid
      character*120,intent(in) :: fname
      integer,      intent(in) :: content(5), signal(12)
      real, allocatable, intent(out) :: t(:)
      real, allocatable, intent(out) :: a(:,:), b(:,:), c(:,:), d(:,:), e(:,:)
    end subroutine
    subroutine read_control_bin(fid,fname,content,signal,t,a,b,c,d,e)
      integer,      intent(in) :: fid
      character*120,intent(in) :: fname
      integer,      intent(in) :: content(5), signal(12)
      real, allocatable, intent(out) :: t(:)
      real, allocatable, intent(out) :: a(:,:), b(:,:), c(:,:), d(:,:), e(:,:)
    end subroutine
  END INTERFACE
  
  !  input file
  logical           :: fxlms, remove_average, no_change_of_sign, yu_contribute
  real              :: mumax, tonfxlms, Tout
  integer           :: learning_method, Nrun, content(5), signal(12), savek
  character*120     :: Pyu_pat, Pzu_pat, K_pat, ctrl_pat

  ! fir 
  real              :: dtp, dtk, dty
  integer           :: ntp(2), ntk(2), nty(2), nyp(2), nyk(2), nyy(2)
  real, allocatable :: Pzu(:,:), Pyu(:,:), K(:,:), v(:,:), m(:,:), K_dum(:,:), K_dum2(:,:)
  
  ! uncontrolled signals
  real, allocatable :: t(:), sy(:,:), sz(:,:), su(:,:), sdio(:,:), sngio(:,:)
  
  ! control variables
  integer           :: n, nt, ny, nz, nu, nybuf, nyybuf, nfbuf, nubuf
  real              :: tau2, sigma2, Lp2Deq, cost, Wu 
  real, allocatable :: y(:,:), z(:,:), u(:,:), fbuf(:,:), ybuf(:,:), zbuf(:,:), ubuf(:,:)
  real, allocatable :: yy(:), zz(:), uu(:), f(:), yu(:), zu(:)
  
  ! output file names
  character*80 :: kfile, cfile

  ! indeces
  integer           :: i,j,run

  ! Unit identification number
  integer, parameter :: fid = 41

  ! Elapsed time
  real :: start_time, end_time

  !! ---  READING DATA --- !!
  ! Read input file
  call read_input_file(fid,fxlms,learning_method,Wu,mumax,tonfxlms,content,signal,Nrun,Tout,savek,&
                       remove_average,no_change_of_sign,yu_contribute,Pyu_pat,K_pat,Pzu_pat,ctrl_pat)
 
  ! Read Pzu, Pyu, K, control.o(.bin)
  call read_fir(fid,Pzu_pat,dtp,ntp,nyp,Pzu)
  if (yu_contribute) then
     call read_fir(fid,Pyu_pat,dty,nty,nyy,Pyu)
  end if
  
  call read_fir(fid,K_pat,dtk,ntk,nyk,K)
  
  if (ctrl_pat(len_trim(ctrl_pat)-3:len_trim(ctrl_pat)).ne.'.bin') then
    call read_control(fid,ctrl_pat,content,signal,t,sy,sz,su,sdio,sngio)
  else
    call read_control_bin(fid,ctrl_pat,content,signal,t,sy,sz,su,sdio,sngio)
  end if

  if (ctrl_pat(len_trim(ctrl_pat)-3:len_trim(ctrl_pat)).ne.'.bin') then
    write(cfile,*) 'controlled.o'
  else
    write(cfile,*) 'controlled.bin'
  end if


  !! --- INITIALISING SOME VARIABLES --- !!
  write(*,*) '========================================================'
  write(*,*) 'Initialization...'
  nt = signal(2)-signal(1)+1
  ny = signal(4)-signal(3)+1
  nz = signal(6)-signal(5)+1
  nu = signal(8)-signal(7)+1
  if ((ny.ne.nz).or.(ny.ne.nu)) then
    write(*,*) 'ERROR: ny, nz, nu must be the same for the current implementation.'
    write(*,*) 'Change values in "signal" to achieve consistency.'
    stop '*** signal dimension inconsitency ***'
  end if
  write(*,*) 'nt is: ',nt
  write(*,*) 'ny is: ',ny
  write(*,*) 'nz is: ',nz
  write(*,*) 'nu is: ',nu

  nybuf  = max(ntp(2),ntk(2))
  nyybuf = nybuf
  nfbuf  = ntk(2)
  nubuf  = ntp(2)
  write(*,*) 'nybuf  is: ',nybuf
  write(*,*) 'nyybuf is: ',nyybuf
  write(*,*) 'nfbuf  is: ',nfbuf
  write(*,*) 'nubuf  is: ',nubuf
  
  if (fxlms) then
    write(*,*) 'Least-descent-method step-size value initialization...'
    tau2   = 0.0
    sigma2 = 0.0
    do j=1,nyp(2)-nyp(1)+1
      do i=1,ntp(2)-ntp(1)+1
        tau2   = tau2   + i*Pzu(j,i)**2
        sigma2 = sigma2 +   Pzu(j,i)**2
      end do
    enddo
    write(*,*) 'tau2: ',tau2,',sigma2: ',sigma2,',ntk(2): ',ntk(2)
    ! L+2*delta_eq definition
    Lp2Deq = ntk(2) + 2*tau2/sigma2
    mumax  = 0.5*mumax/Lp2Deq
    write(*,*) 'Done.'
  end if
  
  write(*,*) 'Allocating array dimensions...'

  allocate(y(nt,ny))
  allocate(z(nt,nz))
  allocate(u(nt,nu))
  
  allocate(fbuf(ny,nfbuf))
  allocate(ybuf(ny,nybuf))
  allocate(zbuf(nz,nyybuf))
  allocate(ubuf(nu,nubuf))
  
  allocate(yy(ny))
  allocate(zz(nz))
  allocate(uu(nu))
  allocate(f(ny))
  allocate(yu(ny))
  allocate(zu(nz))

  allocate(v(size(K,1),size(K,2)))
  allocate(m(size(K,1),size(K,2)))
  allocate(K_dum(size(K,1),size(K,2)))
  allocate(K_dum2(size(K,1),size(K,2)))

  write(*,*) 'Done.'
  write(*,*) '========================================================'
  write(*,*) '========================================================'
  write(*,*) 'Start the simulation...'
  write(*,*) ''

  !! -- SIMULATION -- !!
  call cpu_time(start_time)
  do run=1,Nrun
    
    write(*,*) 'Run number: ',run
    write(*,*) ''

    y = 0
    z = 0
    u = 0
    fbuf = 0
    ybuf = 0
    zbuf = 0
    ubuf = 0
    yy = 0
    zz = 0
    uu = 0
    f  = 0
    yu = 0
    zu = 0

    v = 0
    m = 0
    K_dum = 0
    K_dum2 = 0

    do n = 1,nt

      ! Plant
      yu = 0;
      zu = 0;
      if (yu_contribute) then
         call calc_fir(yu,Pyu,ubuf,nyp,nty,nu,ny,nubuf)
      end if
      call calc_fir(zu,Pzu,ubuf,nyp,ntp,nu,nz,nubuf)
      y(n,:) = yu + sy(n,:)
      z(n,:) = zu + sz(n,:)
      
      ! Remove average from sensors' signals
      if (remove_average) then
         y(n,:) = y(n,:) - sum(y(1:n,1:),1)/n
         z(n,:) = z(n,:) - sum(z(1:n,1:),1)/n
      end if
     
      ybuf(:,2:nybuf)  = ybuf(:,1:nybuf-1)
      ybuf(:,1)  = y(n,:)
      zbuf(:,2:nyybuf) = zbuf(:,1:nyybuf-1)
      zbuf(:,1)  = z(n,:)
     
      call calc_fir(u(n,:),K,ybuf,nyk,ntk,nu,ny,nybuf)
     
      if (no_change_of_sign) then
        ! reverse sign <= to be implemented
      end if
     
      ubuf(:,2:nubuf) = ubuf(:,1:nubuf-1)
      ubuf(:,1)  = u(n,:)
     
      if (fxlms) then
        call calc_fir(f,Pzu,ybuf,nyp,ntp,nu,ny,nybuf)
        
        fbuf(:,2:nfbuf) = fbuf(:,1:nfbuf-1)
        fbuf(:,1)  = f(:)
     
        if (t(n).ge.tonfxlms) then
          ! Write kernel 
          if ((savek.gt.0).and.(mod(n,nt/savek).eq.0)) then
            write(kfile,'(a,I0,a)') 'K.',(n+(run-1)*nt),'.dat'
            call write_fir(fid,kfile,K,dtk,nyk,ntk)
          end if
          !Adaptation step
          select case (learning_method)
            case default
              call lms_step_vanilla(mumax,z(n,:),K,fbuf,nyk,ntk,nz,ny,nfbuf)
              if (Wu.gt.0) then
                call lms_step_vanilla(mumax,Wu*u(n,:),K,ybuf,nyk,ntk,nu,ny,nybuf)
              end if
              K_dum = K_dum + K*(t(2)-t(1))/(t(nt)-tonfxlms)
            case (2)
              call lms_step_momentum(mumax,z(n,:),K,v,fbuf,nyk,ntk,nz,ny,nfbuf)
              if (Wu.gt.0) then
                call lms_step_vanilla(mumax,Wu*u(n,:),K,ybuf,nyk,ntk,nu,ny,nybuf)
              end if
              K_dum = K_dum + K*(t(2)-t(1))/(t(nt)-tonfxlms)
            case (3)
              call lms_step_adam(mumax,z(n,:),K,n-4998,m,v,fbuf,nyk,ntk,nz,ny,nfbuf)
              if (Wu.gt.0) then
                call lms_step_vanilla(mumax,Wu*u(n,:),K,ybuf,nyk,ntk,nu,ny,nybuf)
              end if
              K_dum = K_dum + K*(t(2)-t(1))/(t(nt)-tonfxlms)
              K_dum2 = K_dum2 + (K**2)*(t(2)-t(1))/(t(nt)-tonfxlms)
            case (4)
              call lms_step_adadelta(z(n,:),K,m,v,fbuf,nyk,ntk,nz,ny,nfbuf)
              if (Wu.gt.0) then
                call lms_step_vanilla(mumax,Wu*u(n,:),K,ybuf,nyk,ntk,nu,ny,nybuf)
              end if
          end select
        end if
      end if

      cost = 0
      do i=1,nz
        cost = cost + z(n,i)**2
      end do

      if (mod(n,floor(Tout/(t(2)-t(1)))).eq.0) then
        write(*,*) 'Time t = ',n*(t(2)-t(1)),',  J = ',cost
      end if
      
    end do
  end do 
  call cpu_time(end_time)
  print *,'Elapsed time is: ',end_time-start_time
  
  !! ---  WRITE OUTPUT --- !!
  ! Write Kernel
  write(kfile,*) 'K.restart'
  call write_fir(fid,kfile,K,dtk,nyk,ntk)
  write(kfile,*) 'K_medio.dat'
  call write_fir(fid,kfile,-K_dum,dtk,nyk,ntk)
  write(kfile,*) 'K2_medio.dat'
  call write_fir(fid,kfile,K_dum2,dtk,nyk,ntk)
  ! Write controlled.o
  if (ctrl_pat(len_trim(ctrl_pat)-3:len_trim(ctrl_pat)).ne.'.bin') then
    call write_control(fid,cfile,signal,t,y,z,u,sdio,sngio)
  else
    call write_control_bin(fid,cfile,signal,t,y,z,u,sdio,sngio)
  end if

end program

!========================================================================================

!!-----------------------------------------------------------------------------!!
!!-----------------------------------------------------------------------------!!
!!                                                                             !!
!!                               SUBROUTINES                                   !!
!!                                                                             !!
!!-----------------------------------------------------------------------------!!
!!-----------------------------------------------------------------------------!!

subroutine read_input_file(fid,fxlms,learning_method,Wu,mumax,tonfxlms,content,signal,Nrun,Tout,savek,&
                           remove_average,no_change_of_sign,yu_contribute,Pyu_pat,K_pat,Pzu_pat,ctrl_pat)
  implicit none
  
  integer,      intent(in)  :: fid
  logical,      intent(out) :: fxlms, remove_average, no_change_of_sign, yu_contribute
  real,         intent(out) :: Wu, mumax, tonfxlms, Tout
  integer,      intent(out) :: learning_method, Nrun, content(5), signal(12), savek
  character*120,intent(out) :: Pzu_pat, Pyu_pat, K_pat, ctrl_pat

  character*80 :: infile
  parameter (infile = 'mimo.i')
  integer :: ierror
  
  
  !! --- INITIALIZATION --- !!
  
  fxlms = .false.
  Wu       = 0
  mumax    = 0
  tonfxlms = 0
  content  = 0
  signal   = 0
  Nrun     = 0
  Tout     = 0
  savek    = 0
  remove_average    = .false.
  no_change_of_sign = .false.
  yu_contribute     = .false.
  Pyu_pat  = 'NOPATH'
  K_pat    = 'NOPATH'
  Pzu_pat  = 'NOPATH'
  ctrl_pat = 'NOPATH'
  
  
  !! --- READ INPUT FILE --- !!
  
  ! Open and read infile
  open(unit=fid,file=trim(infile),form='formatted',iostat=ierror)
    write(*,*) '========================================================'
    write(*,*) 'Reading mimo.i:'
    
    read(fid,*) fxlms
    write(*,*) 'FxLMS: ',fxlms
    if (fxlms) then
      read(fid,*) learning_method
      select case (learning_method)
        case default
          write(*,*) 'learning method: "DEFAULT" (SGD: Stochastic Gradient Descent)'
        case (2)
          write(*,*) 'learning method: "2" (SGD with MOMENTUM)'
        case (3)
          write(*,*) 'learning method: "3" (ADAM: Adaptive Moment Estimation)'
        case (4)
          write(*,*) 'learning method: "4" (Adadelta)'
      end select
      read(fid,*) Wu
      write(*,*) 'Wu: ',Wu
      read(fid,*) mumax
      write(*,*) 'mumax: ',   mumax
      read(fid,*) tonfxlms
      write(*,*) 'tonfxlms: ',tonfxlms
    end if
    read(fid,*) content
    write(*,'(a,4I7.0,a)') 'content: ',content
    read(fid,*) signal
    write(*,'(a,12I7.0,a)') 'signal: ',signal
    read(fid,*) Nrun
    write(*,*) 'Nrun: ',   Nrun
    read(fid,*) Tout
    write(*,*) 'Tout: ',   Tout
    read(fid,*) savek
    write(*,*) 'savek: ',  savek
    read(fid,*) remove_average
    write(*,*) 'Remove average: ',   remove_average
    read(fid,*) no_change_of_sign
    write(*,*) 'No change of sign: ',no_change_of_sign
    read(fid,*) yu_contribute
    write(*,*) 'yu_contribute: ',    yu_contribute
    if (yu_contribute) then
      read(fid,*) Pyu_pat
      write(*,*) 'Pyu_pat: ',Pyu_pat
    end if
    read(fid,*) K_pat
    write(*,*) 'K_pat: ',   K_pat
    read(fid,*) Pzu_pat
    write(*,*) 'Pzu_pat: ', Pzu_pat
    read(fid,*) ctrl_pat
    write(*,*) 'ctrl_pat: ',ctrl_pat
    
    write(*,*) 'Input file read.'
    write(*,*) '========================================================'
  close(fid)

end subroutine

!-----------------------------------------------------------------------------

subroutine read_fir(fid,fname,dt,nt,nz,H)
  implicit none
  integer,           intent(in)    :: fid
  character*120,     intent(in)    :: fname
  real,              intent(out)   :: dt
  integer,           intent(out)   :: nt(2), nz(2)
  real, allocatable, intent(out)   :: H(:,:)

  integer :: ierror, i
  
  open(unit=fid,file=trim(fname),form='formatted',iostat=ierror)
    write(*,*) '========================================================'
    write(*,*) 'Reading FIR: '
    write(*,*) fname
    write(*,*) ''

    read(fid,*) dt
    write(*,*) 'dt = ',dt
    read(fid,*) nt
    write(*,*) 'nt = ',nt
    read(fid,*) nz
    write(*,*) 'nz = ',nz
    allocate(H(nz(2)-nz(1)+1,nt(2)-nt(1)+1))
    do i=1,nt(2)-nt(1)+1
      read(fid,*) H(:,i)
    end do

    write(*,*) 'Done.'
    write(*,*) '========================================================'
  close(fid)

end subroutine

!-----------------------------------------------------------------------------

subroutine read_control(fid,fname,content,signal,t,a,b,c,d,e)
  
  ! --------------------- DESCRIPTION ------------------------- !
  ! read_control: reads the signals stored in fname and assumes !
  !               fname to be formatted.                        !
  ! ----------------------------------------------------------- !

  implicit none
  integer,      intent(in) :: fid
  character*120,intent(in) :: fname
  integer,      intent(in) :: content(5), signal(12)

  real, allocatable, intent(out) :: t(:)
  real, allocatable, intent(out) :: a(:,:), b(:,:), c(:,:), d(:,:), e(:,:)
  
  real, allocatable :: aa(:,:), bb(:,:), cc(:,:), ee(:,:)
  integer           :: i, j, ierror
  
  ! --- VARIABLES' MEANING --- !
  
  ! fname: name of the file to be read
  
  ! content(1): number of lines in fname
  ! content(2): number of columns with measures in fname
  ! content(3): number of columns with inputs in fname
  ! content(4): number of columns with inputs disturbance values in fname
  ! content(5): number of columns with outputs disturbance values in fname
  
  ! signal( 1: 2): (start:end) of lines to be read (i.e. time interval)
  ! signal( 3: 4): (start:end) of columns of measures to put in set of measures (y)
  ! signal( 5: 6): (start:end) of columns of measures to put in set of measures (z)
  ! signal( 7: 8): (start:end) of columns of actuations to put in actuation (u)
  ! signal( 9:10): (start:end) of columns of disturbance to put in set of disturbance (d)
  ! signal(11:12): (start:end) of columns of disturbance to put in ste of disturbance (n)
  
  ! aa(:,:): total set of measures from fname
  ! bb(:,:): total set of actuations from fname
  ! cc(:,:): total set of input disturbances from fname
  ! ee(:,:): total set of output disturbances from fname

  ! t(:)  : time series (time interval)
  ! a(:,:): set of measures y
  ! b(:,:): set of measures z
  ! c(:,:): set of actuations u
  ! d(:,:): set of disturbance d
  ! e(:,:): set of disturbance n
  
  allocate(aa(signal(2)-signal(1)+1, content(2))) 
  allocate(bb(signal(2)-signal(1)+1, content(3))) 
  allocate(cc(signal(2)-signal(1)+1, content(4)))
  allocate(ee(signal(2)-signal(1)+1, content(5)))

  allocate(t(signal(2)-signal(1)+1))
  allocate(a(signal(2)-signal(1)+1, signal( 4)-signal( 3)+1))
  allocate(b(signal(2)-signal(1)+1, signal( 6)-signal( 5)+1))
  allocate(c(signal(2)-signal(1)+1, signal( 8)-signal( 7)+1))
  allocate(d(signal(2)-signal(1)+1, signal(10)-signal( 9)+1))
  allocate(e(signal(2)-signal(1)+1, signal(12)-signal(11)+1))
 
  open(unit=fid,file=trim(fname),form='formatted',status='old')
    write(*,*) '========================================================'
    write(*,*) 'Reading control.o: '
    write(*,*) fname
    write(*,*) '...'
    do i=1,content(1)
      j = i-signal(1)+1
      if (j.gt.signal(2)-signal(1)+1) then
        exit
      elseif (j.ge.1) then
        read(fid,*) t(j),aa(j,:),bb(j,:),cc(j,:)
        if (size(aa,2).ne.0)  a(j,:)=aa(j,signal( 3):signal( 4))
        if (size(aa,2).ne.0)  b(j,:)=aa(j,signal( 5):signal( 6))
        if (size(bb,2).ne.0)  c(j,:)=bb(j,signal( 7):signal( 8))
        if (size(cc,2).ne.0)  d(j,:)=cc(j,signal( 9):signal(10))
        if (size(ee,2).ne.0)  e(j,:)=ee(j,signal(11):signal(12))
      else
        read(fid,*)
      end if
    end do
    write(*,*) 'Done.'
    write(*,*) 't(start) = ',t(1)
    write(*,*) 't(end)   = ',t(signal(2)-signal(1)+1)
    write(*,*) '========================================================'
  close(fid)
  
  deallocate(aa)
  deallocate(bb)
  deallocate(cc)
 
end subroutine

!-----------------------------------------------------------------------------

subroutine read_control_bin(fid,fname,content,signal,t,a,b,c,d,e)

  ! --------------------- DESCRIPTION ------------------------- !
  ! read_control_bin: reads the signals stored in fname and     !
  !                   assumes fname to be unformatted (binary). !
  ! ----------------------------------------------------------- !

  implicit none
  integer,      intent(in) :: fid
  character*120,intent(in) :: fname
  integer,      intent(in) :: content(5), signal(12)

  real, allocatable, intent(out) :: t(:)
  real, allocatable, intent(out) :: a(:,:), b(:,:), c(:,:), d(:,:), e(:,:)
  
  real, allocatable :: aa(:,:), bb(:,:), cc(:,:), ee(:,:)
  integer           :: i, j, ierror
  

  allocate(aa(signal(2)-signal(1)+1, content(2)))
  allocate(bb(signal(2)-signal(1)+1, content(3))) 
  allocate(cc(signal(2)-signal(1)+1, content(4))) 
  allocate(ee(signal(2)-signal(1)+1, content(5))) 

  allocate(t(signal(2)-signal(1)+1))
  allocate(a(signal(2)-signal(1)+1, signal( 4)-signal( 3)+1))
  allocate(b(signal(2)-signal(1)+1, signal( 6)-signal( 5)+1))
  allocate(c(signal(2)-signal(1)+1, signal( 8)-signal( 7)+1))
  allocate(d(signal(2)-signal(1)+1, signal(10)-signal( 9)+1))
  allocate(e(signal(2)-signal(1)+1, signal(12)-signal(11)+1))


  open(unit=fid,file=trim(fname),form='unformatted',status='old')
    write(*,*) '========================================================'
    write(*,*) 'Reading control.bin: '
    write(*,*) fname
    write(*,*) '...'
    do i=1,content(1)
      j = i-signal(1)+1
      if (j.gt.signal(2)-signal(1)+1) then
        exit
      elseif (j.ge.1) then
      read(fid) t(i),aa(i,:),bb(i,:),cc(i,:)
        if (size(aa,2).ne.0)  a(j,:)=aa(j,signal( 3):signal( 4))
        if (size(aa,2).ne.0)  b(j,:)=aa(j,signal( 5):signal( 6))
        if (size(bb,2).ne.0)  c(j,:)=bb(j,signal( 7):signal( 8))
        if (size(cc,2).ne.0)  d(j,:)=cc(j,signal( 9):signal(10))
        if (size(ee,2).ne.0)  e(j,:)=ee(j,signal(11):signal(12))
      else
        read(fid,*)
      end if
    end do
    write(*,*) 'Done.'
    write(*,*) 't(start) = ',t(1)
    write(*,*) 't(end)   = ',t(signal(2)-signal(1)+1)
    write(*,*) '========================================================'
  close(fid)
  
  deallocate(aa)
  deallocate(bb)
  deallocate(cc)
 
end subroutine

!-----------------------------------------------------------------------------

subroutine write_fir(fid,fname,H,dt,ninh,nth)

  ! --------------------- DESCRIPTION ------------------------- !
  ! write_fir: writes the array H into a formatted file.        !
  ! ----------------------------------------------------------- ! 
  
  implicit none
 
  integer,      intent(in) :: fid
  character*80, intent(in) :: fname
  integer,      intent(in) :: ninh(2),nth(2)
  real,         intent(in) :: dt, H(ninh(2)-ninh(1)+1,nth(2)-nth(1)+1)
  
  integer :: i, j, ierror
  character*80 :: ioformat
  
  write(ioformat,'(a,I3.0,a)') '(',(ninh(2)-ninh(1)+1),'E24.15)'
  open(unit=fid,file=adjustl(trim(fname)),form='formatted',iostat=ierror)
    write(fid,'(E24.15)') dt
    write(fid,'(2I10)') nth(1),nth(2)
    write(fid,'(2I10)') ninh(1),ninh(2)

    do i=1,nth(2)-nth(1)+1
      write(fid,ioformat) (H(j,i),j=1,ninh(2)-ninh(1)+1)
    end do
  close(fid)
  write(*,*) '---------------------'
  write(*,*) trim(fname),' written.'
  write(*,*) '*********************'

end subroutine

!-----------------------------------------------------------------------------

subroutine write_control(fid,fname,signal,t,a,b,c,d,e)

  ! --------------------- DESCRIPTION ------------------------- !
  ! write_control: writes the arrays t,a,b,c,d,e in a formatted !
  !                output file called "control.o".                 !
  ! ----------------------------------------------------------- !
  
  implicit none

  integer,      intent(in) :: fid
  character*80, intent(in) :: fname
  integer,      intent(in) :: signal(12)

  real,         intent(in) :: t(signal(2)-signal(1)+1)
  real,         intent(in) :: a(signal(2)-signal(1)+1, signal( 4)-signal( 3)+1),&
                              b(signal(2)-signal(1)+1, signal( 6)-signal( 5)+1),&
                              c(signal(2)-signal(1)+1, signal( 8)-signal( 7)+1),&
                              d(signal(2)-signal(1)+1, signal(10)-signal( 9)+1),&
                              e(signal(2)-signal(1)+1, signal(12)-signal(11)+1)

  integer      :: ntot, i, ierror
  character*80 :: ioformat

  ntot = 1+size(a,2)+size(b,2)+size(c,2)+size(d,2)+size(e,2)
  
  write(ioformat,'(a,I3.0,a)') '(',(1+ntot),'E24.16)'
  open(fid,file=adjustl(trim(fname)),form='formatted',iostat=ierror)
    do i=1,size(t)
      write(fid,ioformat) t(i),a(i,:),b(i,:),c(i,:),d(i,:),e(i,:)
    end do
  close(fid)
  write(*,*) '---------------------'
  write(*,*) trim(fname),' written.'
  write(*,*) '*********************'

end subroutine

!-----------------------------------------------------------------------------

subroutine write_control_bin(fid,fname,signal,t,a,b,c,d,e)

  ! --------------------- DESCRIPTION ------------------------- !
  ! write_control_bin: writes the arrays t,a,b,c,d,e in an      !
  !                    unformatted (binary) file called         !
  !                    "control.bin".                           !
  ! ----------------------------------------------------------- !
  
  implicit none

  integer,      intent(in) :: fid
  character*80, intent(in) :: fname
  integer,      intent(in) :: signal(12)

  real,         intent(in) :: t(signal(2)-signal(1)+1)
  real,         intent(in) :: a(signal(2)-signal(1)+1, signal( 4)-signal( 3)+1),&
                              b(signal(2)-signal(1)+1, signal( 6)-signal( 5)+1),&
                              c(signal(2)-signal(1)+1, signal( 8)-signal( 7)+1),&
                              d(signal(2)-signal(1)+1, signal(10)-signal( 9)+1),&
                              e(signal(2)-signal(1)+1, signal(12)-signal(11)+1)

  integer      :: i, ierror

  
  open(fid,file=adjustl(trim(fname)),form='unformatted',iostat=ierror)
    do i=1,size(t)
      write(fid) t(i),a(i,:),b(i,:),c(i,:),d(i,:),e(i,:)
    end do
  close(fid)
  write(*,*) '---------------------'
  write(*,*) trim(fname),' written.'
  write(*,*) '*********************'

end subroutine

!-------------------------------------------------------------------------------

subroutine lms_step_vanilla(mumax,e,H,ubuf,nyh,nth,ne,nu,nbuf)

  ! --------------------- DESCRIPTION ------------------------- !
  ! lms_step_vanilla: computes the kernel H for next time-step  !
  !           by means of Stochastic Gradient Method (SGD)      !
  !           (least-descent-method as in Fabbiane PhD Thesis). !
  ! ----------------------------------------------------------- !

  implicit none
  
  integer, intent(in) :: nyh(2), nth(2), ne, nu, nbuf
  real,    intent(in) :: mumax, e(ne), ubuf(nu,nbuf)
  
  real, intent(inout) :: H(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  
  integer :: j,l,q,p,m,ml
  real    :: grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1), mu, Pxf
  
  INTERFACE
    function fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
      integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
      real,    intent(in) :: e(ne),ubuf(nu,nbuf)
      real :: fxlms_grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
    end function fxlms_grad
  END INTERFACE
  
  ! Step length
  mu = 0.0d0
   
  ! Calculate Pxf
  Pxf = 0.0d0
  do j = 1,nbuf
    do m = 1,nu
      Pxf = Pxf + ubuf(m,j)**2/nbuf/nu
    end do
  end do
 
  !write(*,*) 'Pxf : ',Pxf,', mumax : ',mumax
  mu = mumax!/Pxf
  
  ! Compute the gradient
  grad = fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
  
  ! Kernel update
  do j = 1,nth(2)-nth(1)+1
    do l = 1,nyh(2)-nyh(1)+1
      H(l,j) = H(l,j) - mu*grad(l,j)
    end do
  end do

end subroutine lms_step_vanilla

!-------------------------------------------------------------------------------

subroutine lms_step_momentum(mumax,e,H,v,ubuf,nyh,nth,ne,nu,nbuf)

  ! --------------------- DESCRIPTION ------------------------- !
  ! lms_step_momentum: computes the kernel H for next time-step !
  !           by means of SGD with MOMENTUM, which should speed-!
  !           up SGD convergence.                               !
  !           (Modification of SGD in Fabbiane PhD Thesis).     !
  ! ----------------------------------------------------------- !

  implicit none
  
  integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
  
  real,    intent(in) :: mumax,e(ne),ubuf(nu,nbuf)

  real, intent(inout) :: H(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  real, intent(inout) :: v(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)

  integer :: j,l,q,p,m,ml
  real    :: grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1), mu, Pxf
  real, parameter :: alfa = 0.9, alfa2 = 0.000001

  INTERFACE
    function fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
      integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
      real,    intent(in) :: e(ne),ubuf(nu,nbuf)
      real :: fxlms_grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
    end function fxlms_grad
  END INTERFACE

  ! Step length
  mu = 0.0d0
   
  !! Calculate Pxf
  !Pxf = 0.0d0
  !do j = 1,nbuf
  !  do m = 1,nu
  !    Pxf = Pxf + ubuf(m,j)**2/nbuf/nu
  !  end do
  !end do

  !write(*,*) 'Pxf : ',Pxf,', mumax : ',mumax
  mu = 1.0d0!mumax/Pxf
    
  ! Compute the gradient
  grad = fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
  
  ! Kernel update
  do j = 1,nth(2)-nth(1)+1
    do l = 1,nyh(2)-nyh(1)+1
      v(l,j) = alfa*v(l,j) + mu*grad(l,j)
      H(l,j) = H(l,j) - alfa2*v(l,j)
    end do
  end do

end subroutine lms_step_momentum

!-------------------------------------------------------------------------------

subroutine lms_step_adam(mumax,e,H,t,mt,vt,ubuf,nyh,nth,ne,nu,nbuf)

  ! --------------------- DESCRIPTION ------------------------- !
  ! lms_step_adam: computes the kernel H for next time-step by  !
  !           means of ADAM, a fast adaptive algorithm          !
  ! ----------------------------------------------------------- !

  implicit none
  
  integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf,t
  
  real,    intent(in) :: mumax,e(ne),ubuf(nu,nbuf)

  real, intent(inout) :: H(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  real, intent(inout) :: mt(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  real, intent(inout) :: vt(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)

  integer :: j,l,q,p,m,ml
  real    :: grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1), mu, Pxf
  real    :: m_hat, v_hat
  real, parameter :: b1 = 0.9, b2 = 0.999, eps = 1.0d-08

  INTERFACE
    function fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
      integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
      real,    intent(in) :: e(ne),ubuf(nu,nbuf)
      real :: fxlms_grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
    end function fxlms_grad
  END INTERFACE

  ! Step length
  mu = 0.0d0
   
  ! Calculate Pxf
  Pxf = 0.0d0
  do j = 1,nbuf
    do m = 1,nu
      Pxf = Pxf + ubuf(m,j)**2/nbuf/nu
    end do
  end do
  
  mu = mumax/Pxf
    
  ! Compute the gradient
  grad = fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
  
  ! Kernel update
  do j = 1,nth(2)-nth(1)+1
    do l = 1,nyh(2)-nyh(1)+1
      mt(l,j) = b1*mt(l,j) + (1-b1)*grad(l,j)
      vt(l,j) = b2*vt(l,j) + (1-b2)*grad(l,j)**2
      m_hat = mt(l,j)/(1-b1**t)
      v_hat = vt(l,j)/(1-b2**t)
      H(l,j) = H(l,j) - mu/(sqrt(v_hat)+eps)*m_hat
    end do
  end do

end subroutine lms_step_adam

!-------------------------------------------------------------------------------

subroutine lms_step_adadelta(e,H,mt,vt,ubuf,nyh,nth,ne,nu,nbuf)

  ! --------------------- DESCRIPTION ------------------------- !
  ! lms_step_adadelta: computes the kernel H for next time-step !
  !           by means of Adadelta: is not working              !
  ! ----------------------------------------------------------- !

  implicit none
  
  integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
  
  real,    intent(in) :: e(ne),ubuf(nu,nbuf)

  real, intent(inout) :: H(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  real, intent(inout) :: mt(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  real, intent(inout) :: vt(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)

  integer :: j,l,q,p,m,ml
  real    :: grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1), mu, Pxf
  real    :: delta 
  real, parameter :: alpha = 0.9, eps = 1.0d-08

  INTERFACE
    function fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
      integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
      real,    intent(in) :: e(ne),ubuf(nu,nbuf)
      real :: fxlms_grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
    end function fxlms_grad
  END INTERFACE

  ! Compute the gradient
  grad = fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf)
  
  ! Kernel update
  do j = 1,nth(2)-nth(1)+1
    do l = 1,nyh(2)-nyh(1)+1
      mt(l,j) = alpha*mt(l,j) + (1-alpha)*grad(l,j)**2
      delta   = - sqrt((vt(l,j)+eps)/(mt(l,j)+eps))*grad(l,j)
      vt(l,j) = alpha*vt(l,j) + (1-alpha)*delta**2
      H(l,j)  = H(l,j) + delta
    end do
  end do

end subroutine lms_step_adadelta

!-------------------------------------------------------------------------------

function fxlms_grad(e,ubuf,nyh,nth,ne,nu,nbuf) 
  
  ! --------------------- DESCRIPTION ------------------------- !
  ! fxlms_grad: computes the gradient of the cost function from !
  !           the fxLMS control law (Fabbiane PhD Thesis).      !
  ! ----------------------------------------------------------- !

  implicit none
  
  integer, intent(in) :: nyh(2),nth(2),ne,nu,nbuf
  real,    intent(in) :: e(ne),ubuf(nu,nbuf)
  
  real :: fxlms_grad(nyh(2)-nyh(1)+1,nth(2)-nth(1)+1)
  
  integer :: j,l,q,p,m,ml

  ! Initialize array and compute gradient  
  fxlms_grad = 0.0d0
  do l = 1,ne
    do j = nth(1),nth(2)
      do m = nyh(1),nyh(2)
        ml = mod(m+l-1 + nu,nu) + 1
  !                    + nu: to fix a mod(x,y) problem when x crosses zero
        fxlms_grad(m-nyh(1)+1,j-nth(1)+1) =& 
           fxlms_grad(m-nyh(1)+1,j-nth(1)+1) + 2*e(l)*ubuf(ml,j)
      end do
    end do
  end do

  return

end function fxlms_grad

!-------------------------------------------------------------------------------

subroutine calc_fir(out,H,inbuf,ninh,nth,nout,nin,nbuf)

  ! --------------------- DESCRIPTION ------------------------- !
  ! calc_fir: computes the convolution sum of the kernel H and  !
  !           the array "inbuf" for each output "out" and       !
  !           assumes periodicity (Fabbiane PhD Thesis)         !
  ! ----------------------------------------------------------- !
  
  implicit none
  
  real,  intent(out) :: out(nout)
  
  integer,intent(in) :: ninh(2),nth(2), nout, nin, nbuf
  real,   intent(in) :: inbuf(nin,nbuf),&
                        H(ninh(2)-ninh(1)+1,nth(2)-nth(1)+1)
  
  integer j,l,m,ml,l0
  out = 0.0d0
  
  do m = 1,nout
    do j = nth(1),nth(2)
      do l = ninh(1),ninh(2)
        ml = mod(m+l-1 + nin,nin) + 1
  !                    + nin: to fix a mod(a,b) problem when a crosses zero
        out(m) = out(m) + H(l-ninh(1)+1,j-nth(1)+1) * inbuf(ml,j)
      end do
    end do
  end do

end subroutine calc_fir

